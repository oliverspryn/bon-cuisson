<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:pagesservice="services.pagesservice.*"
		 creationComplete="init(event)">
	<fx:Script>
		<![CDATA[
			import com.forwardfour.boncuisson.events.MenuEvent;
			import com.greensock.TweenMax;
			
			import mx.controls.Alert;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import renderers.Navigation;
			
			import spark.events.IndexChangeEvent;
			
		//The event that is dispatched during a menu item click
			public static const MENU_ITEM_CLICKED:String = "menuItemClicked";
			
			//The event that is dispatched when the menu has finished rendering
			public static const MENU_RENDER_COMPLETE:String = "menuRenderComplete";
			
		//A reference to the current page pointer arrow
			private var pointer:UIComponent;
			
		//Request the menu data from the server and hide the menu scrollbars
			private function init(e:Event):void {
			//Request server data
				menuResponder.token = menu.getAllPages();
				
			//Hide menu scrollbars
				list.scroller.setStyle("verticalScrollPolicy", "off");
			}
			
		//Begin building the visual interface, after the data has been recieved from the server and the stage is accessable
			private function initDisplayObjects(e:ResultEvent):void {
				if (stage) {
					this.positionMenu(new Event(Event.ADDED_TO_STAGE));
				} else {
					this.addEventListener(Event.ADDED_TO_STAGE, positionMenu);
				}
			}
			
		//Add 10% padding to the left and right of the menu links, animate the menu background,
		//and wait until the menu has transitioned into view before displaying the pointer arrow
			private function positionMenu(e:Event):void {
			//Animate the menu background
				TweenMax.to(background, 0.50, {
								onComplete : rollDown,
								width : stage.stageWidth
							});
				
			//Adjust the width of the menu
				list.left = stage.stageWidth / 10;
				list.right = stage.stageWidth / 10;
				
			//Wait until the menu is in view before displaying the pointer arrow
				var delay:Number = 1250;                        //1.25 sec delay for the menu background to transition into place
				delay += menuResponder.lastResult.length * 250; //0.25 sec delay for each item appearing in the menu
				
				var timer:Timer = new Timer(delay, 1);
				timer.addEventListener(TimerEvent.TIMER_COMPLETE, buildPointer);
				timer.start();
			}
			
		//Roll the menu background down
			private function rollDown():void {
				TweenMax.to(background, 0.50, {
								height : 50
							});
			}
			
		//Build the current-menu pointer and position it according to the selected page
			private function buildPointer(e:TimerEvent):void {
			//Remove the event listener
				EventDispatcher(e.target).removeEventListener(e.type, buildPointer);
				
			//Build the pointer
				var pointer:Shape = new Shape();
				var color:uint = 0xFFFFFF;
				var width:int = 10;
				var selectedItemWidth:Number = list.dataGroup.getElementAt(list.selectedIndex).width;
				
				this.pointer = new UIComponent();
				pointer.alpha = 0;
				pointer.x = (stage.stageWidth / 10) + (selectedItemWidth / 2) - (width / 2);
				pointer.y = 50 - width;
				pointer.graphics.beginFill(color);
				pointer.graphics.moveTo(width / 2, 0);
				pointer.graphics.lineTo(width, width);
				pointer.graphics.lineTo(0, width);
				pointer.graphics.lineTo(width / 2, 0);
				pointer.graphics.endFill();
				this.pointer.addChild(pointer);
				this.addElement(this.pointer);
				
			//Transition it into view
				TweenMax.to(pointer, 0.25, {
								alpha : 1,
								onComplete : menuRendered
							});
			}
			
		//Dispatch an event showing that the menu has rendered
			private function menuRendered():void {
				super.dispatchEvent(new Event(Menu.MENU_RENDER_COMPLETE));
			}
			
		//Show an error dialog in the case of an error when communicating with the server
			private function menu_faultHandler(e:FaultEvent):void {
				Alert.show("Fault string: " + e.fault.faultString + "\nFault detail: " + e.fault.faultDetail, e.fault.faultCode);
			}		
			
		//Let the application know that the user has selected a menu item
			private function navigateToPageHandler(e:IndexChangeEvent):void {
			//Collect the event data
				var event:MenuEvent = new MenuEvent(Menu.MENU_ITEM_CLICKED);
				event.menuIndex = list.selectedIndex;
				event.pageID = menuResponder.lastResult[list.selectedIndex].id;
				event.pageURL = menuResponder.lastResult[list.selectedIndex].URL;
				event.pageType = menuResponder.lastResult[list.selectedIndex].type;
				
			//Dispatch the event
				super.dispatchEvent(event);
			}
		]]>
	</fx:Script>
	
<!-- Make a request to the server for each of the menu items -->
	<fx:Declarations>
		<s:CallResponder id="menuResponder"/>
		<pagesservice:PagesService id="menu" showBusyCursor="true" fault="menu_faultHandler(event)" result="initDisplayObjects(event)"/>
	</fx:Declarations>
	
<!-- The background of the menu -->
	<s:Rect id="background" horizontalCenter="0" width="0" height="1">
		<s:fill>
			<s:SolidColor color="0x333333"/>
		</s:fill>
	</s:Rect>
	
<!-- The styled list which will act as the menu -->
	<s:List borderVisible="false" contentBackgroundAlpha="0" id="list" requireSelection="true" itemRenderer="renderers.Navigation" change="navigateToPageHandler(event)">
		<s:layout>
			<s:HorizontalLayout gap="30"/>
		</s:layout>
		
		<s:AsyncListView list="{menuResponder.lastResult}"/>
	</s:List>
</s:Group>
