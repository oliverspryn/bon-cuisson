<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:pagesservice="services.pagesservice.*"
		 creationComplete="init(event)"
		 width="100%">
	<fx:Script>
		<![CDATA[
			import com.forwardfour.boncuisson.events.MenuEvent;
			import com.greensock.TweenMax;
			
			import mx.controls.Alert;
			import mx.core.IVisualElement;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import renderers.Navigation;
			
			import spark.events.IndexChangeEvent;
			
		//The event that is dispatched during a menu item click
			public static const MENU_ITEM_CLICKED:String = "menuItemClicked";
			
		//The event that is dispatched when the menu has finished rendering
			public static const MENU_RENDER_COMPLETE:String = "menuRenderComplete";
			
		//For some reason, the PagesService request is fired each time the user clicks on the menu
		//so prevent the cascade of events that are triggered on success of the service call by
		//keeping track of the first one
			private var hasMenuItems:Boolean = false;
			
		//A reference to the current page pointer arrow
			private var pointer:UIComponent = null;
			
		//For some reason, once the pointer is created and placed, the center of its coordinate
		//system becomes the spot where it was originally placed. For example, if the pointer
		//was placed at 123, 45; then the "x", relative to it, is 0, but relative to the stage
		//is still 123. We need to keep track of this original x location (we don't care about
		//the y location) in order to do calculations and slide it around on the menu when
		//different menu items are selected. GRRRR *releases steam*
			private var xOriginal:Number;
			
		//Slide the arrow to a new menu item
			public function set selected(item:Number):void {
			//Don't do anything if the pointer has not be created, it will be placed in the correct spot ;)
				if (this.pointer != null) {
					item --; //Subtract one to convert to the array zero-based notatation
					list.selectedIndex = item;
					
					var width:int = 10; //Width of the pointer
					var selectedItem:IVisualElement = list.dataGroup.getElementAt(list.selectedIndex);
					var selectedItemX:Number = selectedItem.x;
					var selectedItemWidth:Number = selectedItem.width;
					var xPos:Number = (stage.stageWidth / 10) + selectedItemX + (selectedItemWidth / 2) - (width / 2);
					
				//Why are we doing this? Its really stupid. See the comment above the xOriginal declaration
					xPos = xPos - this.xOriginal; //Yes, we'll need negatives
					
				//Tween the pointer to the proper place
					TweenMax.to(this.pointer, 1, {
									x : xPos
								});
				}
			}
			
		//Request the menu data from the server and hide the menu scrollbars
			private function init(e:Event):void {
			//Request server data
				menuResponder.token = menu.getAllPages();
				
			//Hide menu scrollbars
				list.scroller.setStyle("verticalScrollPolicy", "off");
			}
			
		//Begin building the visual interface, after the data has been recieved from the server and the stage is accessable
			private function initDisplayObjects(e:ResultEvent):void {
				if (!this.hasMenuItems) {
					this.hasMenuItems = true;
					
					if (stage) {
						this.positionMenu(new Event(Event.ADDED_TO_STAGE));
					} else {
						this.addEventListener(Event.ADDED_TO_STAGE, positionMenu);
					}
				}
			}
			
		//Add 10% padding to the left and right of the menu links, animate the menu background,
		//and wait until the menu has transitioned into view before displaying the pointer arrow
			private function positionMenu(e:Event):void {				
			//Animate the menu background
				TweenMax.to(background, 0.50, {
								onComplete : rollDown,
								width : stage.stageWidth
							});
				
			//Adjust the width of the menu
				list.left = stage.stageWidth / 10;
				list.right = stage.stageWidth / 10;
				
			//Wait until the menu is in view before displaying the pointer arrow
				var delay:Number = 1250;                        //1.25 sec delay for the menu background to transition into place
				delay += menuResponder.lastResult.length * 250; //0.25 sec delay for each item appearing in the menu
				
				var timer:Timer = new Timer(delay, 1);
				timer.addEventListener(TimerEvent.TIMER_COMPLETE, buildPointer);
				timer.start();
			}
			
		//Roll the menu background down
			private function rollDown():void {
				TweenMax.to(background, 0.50, {
								height : 40
							});
			}
			
		//Build the current-menu pointer and position it according to the selected page
			private function buildPointer(e:TimerEvent):void {
			//Remove the event listener
				EventDispatcher(e.target).removeEventListener(e.type, buildPointer);
				
			//Build the pointer
				var pointer:Shape = new Shape();
				var color:uint = 0xFFFFFF;
				var width:int = 10; //Width of the pointer
				var selectedItem:IVisualElement = list.dataGroup.getElementAt(list.selectedIndex);
				var selectedItemX:Number = selectedItem.x;
				var selectedItemWidth:Number = selectedItem.width;
				
				this.pointer = new UIComponent();
				pointer.alpha = 0;
				pointer.x = (stage.stageWidth / 10) + selectedItemX + (selectedItemWidth / 2) - (width / 2);
				pointer.y = 40 - width;
				pointer.graphics.beginFill(color);
				pointer.graphics.moveTo(width / 2, 0);
				pointer.graphics.lineTo(width, width);
				pointer.graphics.lineTo(0, width);
				pointer.graphics.lineTo(width / 2, 0);
				pointer.graphics.endFill();
				this.pointer.addChild(pointer);
				this.addElement(this.pointer);
				
			//Why are we doing this? Its really stupid. See the comment above the xOriginal declaration
				this.xOriginal = pointer.x;
				
			//Transition it into view
				TweenMax.to(pointer, 0.25, {
								alpha : 1,
								onComplete : menuRendered
							});
			}
			
		//Dispatch an event showing that the menu has rendered
			private function menuRendered():void {
				super.dispatchEvent(new Event(Menu.MENU_RENDER_COMPLETE));
			}
			
		//Show an error dialog in the case of an error when communicating with the server
			private function menu_faultHandler(e:FaultEvent):void {
				Alert.show("Fault string: " + e.fault.faultString + "\nFault detail: " + e.fault.faultDetail, e.fault.faultCode);
			}		
			
		//Let the application know that the user has selected a menu item
			private function navigateToPageHandler(e:IndexChangeEvent):void {
			//Collect the event data
				var event:MenuEvent = new MenuEvent(Menu.MENU_ITEM_CLICKED);
				event.menuIndex = list.selectedIndex;
				event.pageID = menuResponder.lastResult[list.selectedIndex].id;
				event.pageURL = menuResponder.lastResult[list.selectedIndex].URL;
				event.pageType = menuResponder.lastResult[list.selectedIndex].type;
				
			//Dispatch the event
				super.dispatchEvent(event);
			}
		]]>
	</fx:Script>
	
<!-- Make a request to the server for each of the menu items -->
	<fx:Declarations>
		<s:CallResponder id="menuResponder"/>
		<pagesservice:PagesService id="menu" showBusyCursor="true" fault="menu_faultHandler(event)" result="initDisplayObjects(event)"/>
	</fx:Declarations>
	
<!-- The background of the menu -->
	<s:Rect id="background" horizontalCenter="0" width="0" height="1">
		<s:fill>
			<s:SolidColor color="0x333333"/>
		</s:fill>
	</s:Rect>
	
<!-- The styled list which will act as the menu -->
	<s:List borderVisible="false" contentBackgroundAlpha="0" id="list" requireSelection="true"
			itemRenderer="renderers.Navigation" change="navigateToPageHandler(event)">
		<s:layout>
			<s:HorizontalLayout gap="30"/>
		</s:layout>
		
		<s:AsyncListView list="{menuResponder.lastResult}"/>
	</s:List>
</s:Group>
