<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 creationComplete="configure(event)">
	
	<fx:Script>
		<![CDATA[
			import com.forwardfour.events.ComponentStateEvent;
			import com.forwardfour.events.NetworkEvent;
			import com.forwardfour.events.TransitionEvent;
			import com.greensock.TweenMax;
			
			import mx.controls.Alert;
			import mx.core.FlexGlobals;
			import mx.events.FlexEvent;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
		//Globalize a reference to the main application, so that the instantiated Config class can be accessed
			private var main:Main;
			
		//Globalize a reference to the loaded data
			[Bindable]
			protected var data:Object;
			
		//Set whether this component should transition into view when the requested data has been loaded
			private var transitionOnComplete:Boolean;
			
		//Use the configuration class to set whether or not the Flex busy cursor should show during network activity
			private function configure(e:FlexEvent):void {
				this.main = Main(FlexGlobals.topLevelApplication);
				
				this.dataService.showBusyCursor = this.main.config.showFlexBusyCursor;
			}
			
		//Load the requested data from the server
			public function load(URL:String, transitionOnComplete:Boolean = false):void {
				this.dataService.url = URL;
				this.dataServiceResponder.token = this.dataService.send();
				
				this.transitionOnComplete = transitionOnComplete;
			}
			
		//Share the loaded data with the component, dispatch a data fetched event, and see if the component should be transitioned
			private function dataResultHandler(e:ResultEvent):void {
			//Share the data with the component
				this.data = e.result;
				
			//Dispatch the event
				var eventData:NetworkEvent = new NetworkEvent("loadComplete");
				eventData.data = e.result;
				eventData.headers = e.headers;
				eventData.statusCode = e.statusCode;
				eventData.triggeredObject = this;
				eventData.URL = this.dataService.url;
				
				super.dispatchEvent(eventData);
				
			//Should the component be transitioned into place?
				if (this.transitionOnComplete) {
					this.transitionIn();
				}
			}
			
		//Handle data loading errors
			private function dataFaultHandler(e:FaultEvent):void {
				Alert.show("Data for the ModuleBase could not be fetched.\n\nFault code: " +
							e.fault.faultCode + "\nFault details: " + e.fault.faultDetail, e.fault.faultString);
			}
			
		//Restore the visual appearance of the component, and transition it into place
			public function transitionIn():void {
			//Restore the component
				this.restore();
				
			//Transition it into place
				TweenMax.to(this, (this.main.config.transitionDuration / 1000) / 2, {
					alpha : 1,
					onComplete : transitionInCompleteHandler,
					y : "-=" + this.main.config.transitionLength
				});
			}
			
		//Dispatch an event when transitioning in is complete
			private function transitionInCompleteHandler():void {
				var eventData:TransitionEvent = new TransitionEvent("transitionInComplete");
				eventData.transitionDuration = (this.main.config.transitionDuration / 1000) / 2;
				eventData.transitionType = TransitionEvent.TRANSITION_IN;
				eventData.triggeredObject = this;
				
				super.dispatchEvent(eventData);
			}
			
		//Transition this component out of place
			public function transitionOut(destroyOnComplete:Boolean = true):void {
				TweenMax.to(this, (this.main.config.transitionDuration / 1000) / 2, {
					alpha : 0,
					onComplete : transitionOutCompleteHandler,
					onCompleteParams : new Array(destroyOnComplete),
					y : "+=" + this.main.config.transitionLength
				});
			}
			
		//Dispatch an event when transitioning out is complete and destroy this component's data, if set to do so
			private function transitionOutCompleteHandler(destroyOnComplete:Boolean):void {
			//Dispatch the event
				var eventData:TransitionEvent = new TransitionEvent("transitionOutComplete");
				eventData.transitionDuration = (this.main.config.transitionDuration / 1000) / 2;
				eventData.transitionType = TransitionEvent.TRANSITION_OUT;
				eventData.triggeredObject = this;
				
				super.dispatchEvent(eventData);
				
			//Should this components data and visual appearance be destroyed?
				if (destroyOnComplete) {
					this.destroy();
				}
			}
			
		//Destroy this component's data and visual appearence, and dispatch a destroyed event
			public function destroy():void {
			//Destroy the data the sub-class's components are bound to
				this.data = null;
				
			//Destroy the visual appearance
				this.height = 0;
				this.visible = false;
				
			//Dispatch the destroyed event
				super.dispatchEvent(new ComponentStateEvent("componentDestroyed"));
			}
			
		//Restore this component's visual appearance, and dispatch the restored event. The data is gone :(
			public function restore():void {
			//Restore the component
				this.height = NaN;
				this.invalidateSize();
				this.height = super.measuredHeight;
				
			//Dispatch the restored event
				super.dispatchEvent(new ComponentStateEvent("componentRestored"));
			}
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<s:CallResponder fault="dataFaultHandler(event)" id="dataServiceResponder" result="dataResultHandler(event)"/>
		<s:HTTPService id="dataService"/>
	</fx:Declarations>
	
	<fx:Metadata>
		[Event(name="componentDestroyed", type="com.forwardfour.events.ComponentStateEvent")]
		[Event(name="componentRestored", type="com.forwardfour.events.ComponentStateEvent")]
		[Event(name="loadComplete", type="com.forwardfour.events.NetworkEvent")]
		[Event(name="transitionInComplete", type="com.forwardfour.events.TransitionEvent")]
		[Event(name="transitionOutComplete", type="com.forwardfour.events.TransitionEvent")]
	</fx:Metadata>
</s:Group>